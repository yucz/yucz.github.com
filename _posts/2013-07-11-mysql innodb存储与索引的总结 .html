---
layout: default
title: mysql innodb存储与索引的总结 
description: mysql innodb存储与索引的总结 
categories: [mysql]
tags: [索引]
---


<div class="postText"><h2>Innodb<span style="font-family: 宋体">存储</span></h2>
<p style="text-indent: 21pt"><span style="font-family: 宋体">表空间是逻辑存放所有数据的地方，默认情况下会共享一个表空间——</span>ibdata1<span style="font-family: 宋体">，但如果把</span>innodb_file_per_table=ON<span style="font-family: 宋体">后每张表可以单独放到一个表空间内，但还是有很多数据保存在共享的表</span>ibdata1<span style="font-family: 宋体">中，如</span>undo<span style="font-family: 宋体">信息等。</span></p>
<p style="text-indent: 21pt">&nbsp;</p>
<p style="text-indent: 21pt"><span style="font-family: 宋体">表空间由各种段</span>(segment)<span style="font-family: 宋体">组成，常见的段有数据段、索引段等。</span>Innodb<span style="font-family: 宋体">是索引组织的，数据段就是</span>clustered index<span style="font-family: 宋体">的叶结点。需要注意的是，不是每个对象都有段。</span></p>
<p style="text-indent: 21pt">&nbsp;</p>
<p style="text-indent: 21pt"><span style="font-family: 宋体">区</span>(extend)<span style="font-family: 宋体">是由</span>64<span style="font-family: 宋体">个连续的页组成，每个页（</span>page<span style="font-family: 宋体">）固定为</span>16KB<span style="font-family: 宋体">，所以每个区总共为</span>1M<span style="font-family: 宋体">。页是</span>innodb<span style="font-family: 宋体">最小的磁盘管理单位。</span></p>
<p style="text-indent: 21pt">&nbsp;</p>
<p style="text-indent: 21pt">Innodb<span style="font-family: 宋体">是按行进行存放的，每个区最少可以保存</span>2<span style="font-family: 宋体">条记录，否则就成链式结构了。每行数据除了自定义列以外，还会增加事务</span>id<span style="font-family: 宋体">和回滚指针列。如果没有定义</span>primary key<span style="font-family: 宋体">也没有</span>not null<span style="font-family: 宋体">的</span>unique,<span style="font-family: 宋体">则会增加</span>6<span style="font-family: 宋体">字节的</span>RowId<span style="font-family: 宋体">列作为主键。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img border="0" alt="" src="http://images.cnblogs.com/cnblogs_com/chjw8016/UseInCode/BBB.jpg" width="569" height="345"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图片来自：<a href="http://www.cnblogs.com/chjw8016/archive/2011/03/08/1976891.html">http://www.cnblogs.com/chjw8016/archive/2011/03/08/1976891.html</a><br><br></span></p>
<p style="text-indent: 21pt"></p>
<h2>Innodb<span style="font-family: 宋体">表的限制</span></h2>
<p style="text-align: left; line-height: 17.25pt;background: white; vertical-align: baseline" align="left"><span style="border-bottom: windowtext 1pt; border-left: windowtext 1pt; padding-bottom: 0cm; padding-left: 0cm; padding-right: 0cm; font-family: 'Helvetica','sans-serif'; color: black; font-size: 10pt; border-top: windowtext 1pt; border-right: windowtext 1pt; padding-top: 0cm">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family: 宋体">一个表不能包含超过</span>1000<span style="font-family: 宋体">列。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left">&nbsp;&nbsp;<span style="font-family: 宋体">内部最大键长度是</span>3500<span style="font-family: 宋体">字节，但</span>MySQL<span style="font-family: 宋体">自己限制这个到</span>1024<span style="font-family: 宋体">字节。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left">&nbsp;&nbsp;<span style="font-family: 宋体">除了</span>VARCHAR, BLOB<span style="font-family: 宋体">和</span>TEXT<span style="font-family: 宋体">列，最大行长度稍微小于数据库页的一半。即，最大行长度大约</span>8000<span style="font-family: 宋体">字节。</span>LONGBLOB<span style="font-family: 宋体">和</span>LONGTEXT<span style="font-family: 宋体">列必须小于</span>4GB, <span style="font-family: 宋体">总的行长度，页包括</span>BLOB<span style="font-family: 宋体">和</span>TEXT<span style="font-family: 宋体">列，必须小于</span>4GB<span style="font-family: 宋体">。</span>InnoDB<span style="font-family: 宋体">在行中存储</span>VARCHAR<span style="font-family: 宋体">，</span>BLOB<span style="font-family: 宋体">或</span>TEXT<span style="font-family: 宋体">列的前</span>768<span style="font-family: 宋体">字节，余下的存储的分散的页中。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left"><span style="font-family: 宋体">虽然</span>InnoDB<span style="font-family: 宋体">内部地支持行尺寸大于</span>65535<span style="font-family: 宋体">，你不能定义一个包含</span>VARCHAR<span style="font-family: 宋体">列的，合并尺寸大于</span>65535<span style="font-family: 宋体">的行。</span></p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql&gt; CREATE TABLE t (a VARCHAR(8000), b VARCHAR(10000),</p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-&gt; c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),</p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;-&gt; f VARCHAR(10000), g VARCHAR(10000));</p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ERROR 1118 (42000): Row size too large. The maximum row size for the</p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; used table type, not counting BLOBs, is 65535. You have to change some</p>
<p style="text-align: left; line-height: 18.75pt;background: white; vertical-align: baseline" align="left">·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; columns to TEXT or BLOBs</p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left">&nbsp;<span style="font-family: 宋体">在一些更老的操作系统上，数据文件必须小于</span>2GB<span style="font-family: 宋体">。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left">&nbsp;InnoDB<span style="font-family: 宋体">日志文件的合并尺寸必须小于</span>4GB<span style="font-family: 宋体">。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left"><span style="font-family: 宋体">最小的表空间尺寸是</span>10MB<span style="font-family: 宋体">。最大的表空间尺寸是</span>4,000,000,000<span style="font-family: 宋体">个数据库页（</span>64TB<span style="font-family: 宋体">）。这也是一个表的最大尺寸。</span></p>
<p style="text-align: left; line-height: 17.25pt; text-indent: 21pt;background: white; vertical-align: baseline" align="left">&nbsp;InnoDB<span style="font-family: 宋体">表不支持</span>FULLTEXT<span style="font-family: 宋体">索引</span></p>
<p style="text-indent: 21pt">&nbsp;</p>
<h2>Innodb<span style="font-family: 宋体">索引</span></h2>
<p style="text-indent: 21pt"><span style="font-family: 宋体">默认情况下</span>Memory<span style="font-family: 宋体">使用存储</span>hash<span style="font-family: 宋体">索引，但也支持</span>b+tree<span style="font-family: 宋体">索引。</span>Hash<span style="font-family: 宋体">索引只用于</span>=<span style="font-family: 宋体">或者</span>&lt;=&gt;<span style="font-family: 宋体">的等式比较，不能用来加速</span>order by<span style="font-family: 宋体">操作，只能通过关键字来搜索一行。</span>innodb<span style="font-family: 宋体">只支持</span>b+<span style="font-family: 宋体">树索引，进一步分为</span>clustered index <span style="font-family: 宋体">与　</span>secondary index<span style="font-family: 宋体">。在一次查询中，只能使用一个索引。</span></p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p style="text-indent: 10.5pt; margin: 0cm 0cm 0pt 10.5pt">Innodb<span style="font-family: 宋体">是索引组织表，</span>clustered index<span style="font-family: 宋体">的叶结点保存着整行的数据。如果，定义了</span>primary key<span style="font-family: 宋体">，则</span>clustered index<span style="font-family: 宋体">就是</span>primary key<span style="font-family: 宋体">的索引；如果没有定义</span>primary key mysql<span style="font-family: 宋体">会选中第一个仅有</span>not null<span style="font-family: 宋体">列的</span>unique<span style="font-family: 宋体">索引作为主键，并把此索引当作</span>clustered index<span style="font-family: 宋体">使用；如果没找到这样的列，</span>innodb<span style="font-family: 宋体">会创建一个</span>6<span style="font-family: 宋体">字节的</span>RowId<span style="font-family: 宋体">作为主键。所以每张表有且只有一个</span>clustered index<span style="font-family: 宋体">。</span></p>
<p>&nbsp;</p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Secondary index</span><span style="font-family: 宋体">的叶结点不包括行的全部数据，包含键值以外还包括一个</span>bookmark<span style="font-family: 宋体">，可以告诉</span>innodb<span style="font-family: 宋体">到什么地方可以找到相对应的完整行数据，还保存了主键的健值。</span>Secondary index<span style="font-family: 宋体">包含主键，但不包含完整的行数据，所以</span>innodb<span style="font-family: 宋体">总是会先从</span>secondary index<span style="font-family: 宋体">的叶节点判断是否能得到所需的数据。如</span>,</p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Create table t(a int, b varchar(20), primary key(a), key(b));</span></p>
<p style="text-indent: 21pt">Explain select * from t;</p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体">会发现</span>mysql<span style="font-family: 宋体">选择了索引</span>b<span style="font-family: 宋体">，而不是</span>a.</p>
<h2><span style="font-family: 宋体">复合索引</span></h2>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体">复合索引是在多列（</span>&gt;=2<span style="font-family: 宋体">）上建立的索引，又叫多列索引或联合索引。</span>Innodb<span style="font-family: 宋体">中的复合索引也是</span>b+ tree<span style="font-family: 宋体">结构。索引的数据包含多列</span>(col1, col2, col3…)<span style="font-family: 宋体">，在索引中依次按照</span>col1, col2, col3<span style="font-family: 宋体">排序。如</span>(1, 2), (1, 3),(2,0)…</p>
<p>&nbsp;</p>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体">使用复合索引要充分利用最左前缀原则，顾名思义，就是最左优先。如创建索引</span>ind_col1_col2(col1, col2)<span style="font-family: 宋体">，那么在查询</span>where col1 = xxx and col2 = xx<span style="font-family: 宋体">或者</span>where col1 = xxx<span style="font-family: 宋体">都可以走</span>ind_col1_col2<span style="font-family: 宋体">索引。</span></p>
<p style="text-indent: 21pt"><span style="font-family: 宋体">在创建多列索引时，要根据业务需求，</span>where<span style="font-family: 宋体">子句中使用最频繁且过滤效果好的的一列放在最左边。</span></p>
<h2><span style="font-family: 宋体">索引操作</span></h2>
<p><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体">可以通过</span>DML<span style="font-family: 宋体">语句操作</span>innodb<span style="font-family: 宋体">索引。因为</span>innodb<span style="font-family: 宋体">是索引组织的表，对索引的操作会造成锁表，先生成一张临时表，将数据从原始表中写到临时表，再将原始表删除，最后将临时表表名改为原始表表名！因增加、删除、修改字段会对主索引产生影响，所以也会锁表。对</span>secondary index<span style="font-family: 宋体">从</span>Innodb plugin<span style="font-family: 宋体">开始，支持快速索引创建的方法，在创建的过程中不需要重建表，所以速度会很快，同时引擎会在表上加</span>S<span style="font-family: 宋体">锁，在创建过程中只能进行读操作。</span></p>
<h2><span style="font-family: 宋体">索引设计原则</span></h2>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>1.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">搜索的索引列，不一定是所要选择的列。也就是说，最适合索引的列是出现在</span>where<span style="font-family: 宋体">子句中的列，或者连接子句中指定的列，而不是出现在</span>select<span style="font-family: 宋体">关键字后的选择列表中的列。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>2.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">使用唯一索引。考虑某列的分布，索引的列的基数越大，索引的效果越好。例如，对性别</span>M/F<span style="font-family: 宋体">列做索引没多大用处。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>3.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">使用短索引。如果是对字符串进行索引，如果有可能应该指定前缀长度。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>4.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">利用最左前缀。尽量将使用频繁且过滤效果好的字段放“左边”</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>5.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">不要过度索引。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>6.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span>Innodb<span style="font-family: 宋体">默认会按照一定的顺序保存数据，如果明确定义了主键，则按照主键顺序保存。如果没有主键，但有唯一索引，就按照唯一索引的顺序保存。如果有几个列都是唯一的，都可以作为主键的时候，为了提高查询效率，应选择最常用访问的列作为主键。另外，</span>innodb<span style="font-family: 宋体">的</span>secondary index<span style="font-family: 宋体">都会保存主键的键值，所有主键要尽可能选择较短的数据类型。可以看出，应当尽量避免对主键的修改。经过</span>dba<span style="font-family: 宋体">的测试，保证主键的递增可以提高插入性能。</span></p>
<p>&nbsp;</p>
<h2>Mysql<span style="font-family: 宋体">如何使用索引</span></h2>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>1.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">对于创建的多列索引，只要查询的条件中用到了最左边的列，索引一般就会被使用。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>2.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">对于使用</span>like<span style="font-family: 宋体">的查询，后面如果是常量并且只有</span>%<span style="font-family: 宋体">号不在第一个字符，索引才可能被使用。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>3.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">如果对大文本进行搜索，应该使用全文索引，而不是使用</span>like ‘%...%’. <span style="font-family: 宋体">但不幸的是</span>innodb<span style="font-family: 宋体">不支持全文索引。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>4.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">如果列名是索引，使用</span> index_column is null<span style="font-family: 宋体">将使用索引。</span>Oracle<span style="font-family: 宋体">是不行的。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>5.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">如果</span>mysql<span style="font-family: 宋体">估计使用索引比全表扫描更慢，最不会使用索引。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>6.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">如果使用</span>memory/head<span style="font-family: 宋体">表并且</span>where<span style="font-family: 宋体">条件中不使用</span>”=”<span style="font-family: 宋体">进行索引列，那么不会用到索引。</span>Head<span style="font-family: 宋体">表只有在</span>”=”<span style="font-family: 宋体">的时候才会使用索引。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>7.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">用</span>or<span style="font-family: 宋体">分割开的条件，如果</span>or<span style="font-family: 宋体">前的条件中的列有索引，而后面列中没有索引，那么涉及到的索引都不会被用到。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>8.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">不是多列索引的第一部分不会走索引。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>9.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family: 宋体">以</span>%<span style="font-family: 宋体">开始的</span>like<span style="font-family: 宋体">不会走索引</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>10.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp; </span></span><span style="font-family: 宋体">如果列是字符串，那么一定要在</span>where<span style="font-family: 宋体">条件中把字符串常量值用引号引起来，否则不能走索引。因为，</span>mysql<span style="font-family: 宋体">默认把输入的常量值进行转换以后才进行检索。</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>11.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp; </span></span><span style="font-family: 宋体">经过普通运算或函数运算后的索引字段不能使用索引</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>12.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp; </span></span><span style="font-family: 宋体">不等于操作不能使用索，</span>&lt;&gt;<span style="font-family: 宋体">、</span>not in<span style="font-family: 宋体">等</span></p>
<p style="text-indent: -18pt; margin: 0cm 0cm 0pt 18pt"><span>13.<span style="font: 7pt 'Times New Roman'">&nbsp;&nbsp; </span></span>Order by <span style="font-family: 宋体">优化：某些情况下，</span>mysql<span style="font-family: 宋体">可以使用一个索引满足</span>order by,<span style="font-family: 宋体">而不需要额外的排序。</span>Where<span style="font-family: 宋体">条件与</span>order by <span style="font-family: 宋体">使用相同的索引，并且</span>order by<span style="font-family: 宋体">的顺序和索引顺序相同，并且</span>order by<span style="font-family: 宋体">的字段都是升序或者都是降序。</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 ORDER BY key_part1,key_part2,... ;</p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 WHERE key_part1=1 ORDER BY key_part1 DESC, key_part2</p>
<p style="margin: 0cm 0cm 0pt 18pt">DESC;</p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 DESC;</p>
<p style="margin: 0cm 0cm 0pt 18pt"><span style="font-family: 宋体">但是以下情况不使用索引：</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC <span style="font-family: 宋体">；</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">--order by <span style="font-family: 宋体">的字段混合</span> ASC <span style="font-family: 宋体">和</span> DESC</p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 WHERE key2=constant ORDER BY key1 <span style="font-family: 宋体">；</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">-- <span style="font-family: 宋体">用于查询行的关键字与</span> ORDER BY <span style="font-family: 宋体">中所使用的不相同</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">SELECT * FROM t1 ORDER BY key1, key2 <span style="font-family: 宋体">；</span></p>
<p style="margin: 0cm 0cm 0pt 18pt">-- <span style="font-family: 宋体">对不同的关键字使用</span> ORDER BY <span>&nbsp;&nbsp;&nbsp;&nbsp; </span></p>
<p>&nbsp;</p>
<p><span style="font-family: 宋体">可以使用</span>explain<span style="font-family: 宋体">查看</span>sql<span style="font-family: 宋体">的执行计划。</span></p></div>